/** The purpose of this js file is to serve as the controller for the "logic" of the game. This includes:
  - Player actions
  - Enemy actions
  - keyboard to game controls
**/

var gameState; //Used to store the current state of the game (loading, title, running, or dead)
var map; //abstract representation of what the map looks like
var monsters = []; //list containing the locations of all monsters on this floor of the dungeon
var level; //current floor the player is visiting

/**
* Function for all the bookkeeping necessary at the beginning of the game
*
*/
function init_game(){

}

/**
* Function used to create a set of monsters belonging to the current floor from a set of locations generated by dun_gen.js
*/
function init_monsters(locations){
	//console.log("Initializing Monsters. set of locations:", locations.length )
	for(let i=0; i<locations.length; i++){
		monsters.push(new gent_mantis(locations[i][0],locations[i][1]) ); //create a new monster at that location
	}
	return monsters;
}

class Monster{
	constructor(tile, sprite, hp, speed, name){
		this.curr_tile = tile;
        this.location = [tile.x, tile.y]; //set the current location of the monster to the constructor tile
        this.sprite = sprite;
        this.hp = hp;
        this.speed = speed;
        this.name = name;
        this.state = 'neutral'; //starting state of the monster is neutral. 
        //note that the possible states for the monster are 'neutral,' 'flee,' and 'aggro'
	}

	moveNorth(){
		if(tryMove(map[this.curr_tile.x][this.curr_tile.y+1])){
			this.curr_tile = map[this.curr_tile.x][this.curr_tile.y+1]; //update the current tile
		}
	}

	moveSouth(){
		if(tryMove(map[this.curr_tile.x][this.curr_tile.y-1])){
			this.curr_tile = map[this.curr_tile.x][this.curr_tile.y-1]; //update the current tile
		}
	}

	moveEast(){
		if(tryMove(map[this.curr_tile.x+1][this.curr_tile.y])){
			this.curr_tile = map[this.curr_tile.x+1][this.curr_tile.y]; //update the current tile
		}
	}

	moveWest(){
		if(tryMove(map[this.curr_tile.x-1][this.curr_tile.y])){
			this.curr_tile = map[this.curr_tile.x-1][this.curr_tile.y]; //update the current tile
		}
	}

	random_walk(){
		let dice_roll = Math.random();
		if(dice_roll<0.25) this.moveNorth();
		else if(dice_roll<0.50) this.moveEast();
		else if(dice_roll<0.75) this.moveSouth();
		else if(dice_roll<1.0) this.moveWest();
	}

}

//gentleman mantis
class gent_mantis extends Monster{
	constructor(x,y){
		super(map[x][y],'textures/mantis.jpeg',5,1, 'Gentleman Mantis');
	}

	update(){
		if(this.hp <= 0) state = 'dead';
		if(this.state == 'neutral'){
			this.random_walk();
		}
		if(this.state == 'dead'){
			//do nothing
		}
	}
}


class PC{
	constructor(direction,hp, position){
		this.direction = direction;
		this.hp = hp;
		this.position = position;
		this.xPos = position[0];
		this.yPos = position[1];
		this.weapon = new simple_blade; 
		console.log("New Player: " , direction,hp,this.xPos,this.yPos);
	};

	//Player takes an in-game action of a certain type. In game actions cause all monsters in the floor to update their current action
	//Note that monsters may choose to do nothing
	//also note that I don't include rotating in the following actions. The PC rotating does not count as a move or as any other type of action
	pc_action(opCode){
		if(opCode == 0) this.moveForward();
		else if(opCode == 1) this.moveBackward();
		else if(opCode == 2) this.strafeLeft();
		else if(opCode == 3) this.strafeRight();
		for(let i =0; i<monsters.length; i++){
			monsters[i].update(); //update the action of every monster in the list
		}
	}

	moveForward(){
		var nextTile;
		console.log("Move forward");
		if(this.direction == 'north' ) nextTile = map[this.xPos][this.yPos+1];
		else if(this.direction == 'east' ) nextTile = map[this.xPos+1][this.yPos];
		else if(this.direction == 'south' ) nextTile = map[this.xPos][this.yPos-1];
		else if(this.direction == 'west' ) nextTile = map[this.xPos-1][this.yPos];
		
		if(tryMove(nextTile)){
			this.xPos = nextTile.x; this.yPos = nextTile.y;
		}
		else if(nextTile.type == 2){
			confirm('Move on to the next floor?');
		}
		else{
			console.log("Can't move there");
			return false;
		}
	}

	moveBackward(){
		var nextTile;
		console.log("Move backward");
		if(this.direction == 'north' ) nextTile = map[this.xPos][this.yPos-1];
		else if(this.direction == 'east' ) nextTile = map[this.xPos-1][this.yPos];
		else if(this.direction == 'south' ) nextTile = map[this.xPos][this.yPos+1];
		else if(this.direction == 'west' ) nextTile = map[this.xPos+1][this.yPos];

		if(tryMove(nextTile)){
			this.xPos = nextTile.x; this.yPos = nextTile.y;
		}
		else if(nextTile.type == 2){
			confirm('Move on to the next floor?');
		}
		else{
			console.log("Can't move there");
			return false;
		}
	}

	strafeLeft(){
		var nextTile;
		console.log("Strafe Left");
		if(this.direction == 'north' ) nextTile = map[this.xPos-1][this.yPos];
		else if(this.direction == 'east' ) nextTile = map[this.xPos][this.yPos+1];
		else if(this.direction == 'south' ) nextTile = map[this.xPos+1][this.yPos];
		else if(this.direction == 'west' ) nextTile = map[this.xPos][this.yPos-1];	

		if(tryMove(nextTile)){
			this.xPos = nextTile.x; this.yPos = nextTile.y;
		}
		else if(nextTile.type == 2){
			confirm('Move on to the next floor?');
		}
		else{
			console.log("Can't move there");
			return false;
		}
	}

	strafeRight(){
		var nextTile;
		console.log("Strafe Right");
		if(this.direction == 'north' ) nextTile = map[this.xPos+1][this.yPos];
		else if(this.direction == 'east' ) nextTile = map[this.xPos][this.yPos-1];
		else if(this.direction == 'south' ) nextTile = map[this.xPos-1][this.yPos];
		else if(this.direction == 'west' ) nextTile = map[this.xPos][this.yPos+1];	

		if(tryMove(nextTile)){
			this.xPos = nextTile.x; this.yPos = nextTile.y;
		}
		else if(nextTile.type == 2){
			confirm('Move on to the next floor?');
		}
		else{
			console.log("Can't move there");
			return false;
		}
	}

	//Update the state machine used to determine the PC's faced direction
	rotateRight(){
		
		if(this.direction == 'north') this.direction = 'east';
		else if(this.direction == 'east') this.direction = 'south';
		else if(this.direction == 'south') this.direction = 'west';
		else if(this.direction == 'west') this.direction = 'north';
		printToMessageBox(this.direction);
	}
	//Update the state machine used to determine the PC's faced direction
	rotateLeft(){
		if(this.direction == 'north') this.direction = 'west';
		else if(this.direction == 'west') this.direction = 'south';
		else if(this.direction == 'south') this.direction = 'east';
		else if(this.direction == 'east') this.direction = 'north'; 
		printToMessageBox(this.direction);
	}

	//pass a reference to the monster you want to attack
	attack(monster){
		if(inRange(monster.location))monster.hp -= this.weapon.damage; //decrement the monster's HP by the currently equipped weapon's damage
		else console.log("Target not in range");

		for(let i =0; i<monsters.length; i++){
			monsters[i].update(); //update the action of every monster in the list
		}
	}

	//return whether the monster is in range given your equipped weapon 
	inRange(monster_loc){
		let dist = Math.sqrt(Math.pow((monster_loc[0]-this.position[0]),2)+Math.pow((monster_loc[0]-this.position[0]),2))
		if(dist <= this.weapon.range){
			monster.hp -= this.weapon.damage;
		}
	}
}

function setMap(newMap){
	map = newMap; //passed in a 2d array of coordinate pairs
	//console.log("Map received in game_logic: ", map);
}

/**
	Pass a tile to this function to determine whether the character can move into this space
*/ 
function tryMove(tile){
	return tile.passable; //return whether the tile you want to move to is passable or not
}

class weapon{
	constructor(range, damage, name){
		this.range = range;
		this.damage = damage;
		this.name = name;
	}
}

class simple_blade extends weapon{
	constructor(){
		super(1,2,'Simple Blade');
	}
}

//Function used to print messages from enemies and from the game engine to the in-game screen.
function printToMessageBox(string_){
	var messageBox = document.getElementById('messageBox');
    
    // Create some element, e.g. div
    var newElement = document.createElement('div');
    newElement.setAttribute('id', "some-id-for-new-element");
    
    newElement.innerHTML = string_;
    
    messageBox.appendChild(newElement);
}